\chapter{Conclusion}\label{chap:conclusion}

The goal of this thesis was to design a Str8ts solver using equational reasoning. We chose Haskell as the programming language due to its strong academic foundations. We set up the development environment using GHCup and Stack.

Our work draws inspiration from Richard Bird’s \textit{A Simple Sudoku Solver}, a well-known functional pearl. Functional pearls emphasize instructional value over novelty. Throughout this thesis, we followed Bird’s methodology described in \textit{How to Write a Functional Pearl}. However, we treated it as a strict requirement only in the chapters focused on algorithm design. Overall, we put considerable effort into refinements, such as function naming and presentation order.

The chapter \nameref{chap:related-work} surveyed existing Str8ts solvers and helped us position this work within the existing research landscape. A Google Scholar search for “str8ts solver” returned nine papers, none of which provided an actual algorithm. A GitHub search found 23 repositories, five of them written in Haskell. Interestingly, all five were course assignments from the State University of Santa Catarina, suggesting that Haskell’s apparent popularity for this problem was coincidental rather than organic. This demonstrated that there was genuine room for research in this area.

In the \nameref{chap:str8ts} chapter, we introduced the game. Str8ts puzzles come in numerous variations, but we focused on the classic $9 \times 9$ grid while ensuring the solver remains easily parameterizable. Notably, a Str8ts puzzle without black fields is equivalent to a Sudoku puzzle without the box rule. We leveraged these structural similarities in \nameref{chap:data-representation}, \nameref{chap:a-simple-solver}, and \nameref{chap:an-advanced-solver}, which enabled the reuse of Bird’s transformation steps. Once we had carefully designed the data representation, iteratively refining a simple solver into a more efficient one became straightforward.

\newpage
The evaluation was conducted on a MacBook Pro using two main Haskell modules: PuzzleDownloader for retrieving puzzle data and RuntimeAnalyser for measuring run-time metrics. Using all 365 published in 2023 on the official Str8ts website, we observed that the simple solver was too slow for practical benchmarking, while the advanced solver demonstrated both theoretical correctness and practical efficiency.

Overall, we view Bird's method with a critical eye. It has clear advantages. It encouraged us to write both reusable and readable functions. The absence of index operations contributes significantly to this. The method also provides strong mathematical guarantees of correctness. However, algorithm design through equational reasoning requires significant effort. It requires a level of mathematical skill that not all programmers possess. Deriving transformations is often much more complicated than applying general programming techniques, such as backtracking. The former is highly domain-specific, while the latter is more general and broadly applicable.

We are left wondering whether Bird’s approach is mainly a theoretical exercise -- a way to highlight the elegance of functional programming -- or whether it has real practical value. At the same time, it showed us how mathematics and programming can go hand in hand. On a smaller scale -- maybe not for building entire programs, but for improving parts of one -- we believe equational reasoning can be profoundly beneficial.