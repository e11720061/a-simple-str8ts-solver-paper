\chapter{A Simple Solver}\label{chap:a-simple-solver}

Now we can proceed with algorithm design. In a first step, we define a straightforward solution, $simpleSolve$, that employs a brute-force approach with no concern for performance or optimization.

The function $simpleSolve$ takes a grid as input and systematically generates all possible completions, both valid and invalid. By filtering out the invalid ones, we obtain the complete solution space. The algorithm correctly handles cases with zero, one, or multiple valid solutions. If the input grid itself is invalid (for example, if a row contains duplicate values), $simpleSolve$ returns an empty list.

Thanks to Haskell’s lazy evaluation, only the necessary portions of the result are computed. As a result, if only the first valid solution is required, it can be retrieved more efficiently using the $head$ function.

\[
\begin{array}{lcl}
    simpleSolve & :: & Grid \rightarrow [Grid] \\
    simpleSolve & = & filter~valid~.~completions
\end{array} \\
\]

\section*{Choices}
\addcontentsline{toc}{section}{Choices}

We compute all possible completions in two steps. First, we need to replace each square with the choices we have for it. Then we can apply the matrix cartesian product.

\[
    \begin{array}{lcl}
        completions & :: & Grid \rightarrow [Grid] \\
        completions & = & mcp~.~choices
    \end{array} \\
\]

\newpage

We begin by introducing a new data type \(Choices\).

\[
    \begin{array}{lcl}
        \textbf{type}~Choices & = & [Square] \\
    \end{array} \\
\]

We know that each blank square needs to be filled with a number between 1 and 9. We call the set of these values \(candidates\).

\[
    \begin{array}{lcl}
        candidates & :: & Choices \\
        candidates & = & [Square~White~v~|~v~\leftarrow~[1~..~size]]
    \end{array} \\
\]

Based on that, we define the function \(choices\).

\[
    \begin{array}{lcl}
        choices & :: & Grid \rightarrow Matrix~Choices \\
        choices & = & map~(map~choice)
    \end{array}
\]

\[
    \begin{array}{lcl}
        choice & :: & Square \rightarrow Choices \\
        choice & = & \textbf{if}~blank~s~\textbf{then}~candidates~\textbf{else}~[s]
    \end{array}
\]

The matrix cartesian product is given by

\[
    \begin{array}{lcl}
        mcp & :: & Matrix~[a] \rightarrow [Matrix ~ a] \\
        mcp & = & cp~.~map~cp
    \end{array}
\]
\[
    \begin{array}{lcl}
        cp & :: & [[a]] \rightarrow [[a]] \\
        cp ~ [] & = & [[]] \\
        cp~(xs:xss) & = & [x:ys~|~x \leftarrow xs,~ys \leftarrow cp~xss]
    \end{array}
\]

\section*{Validity}
\addcontentsline{toc}{section}{Validity}

Last but not least, we have to implement the function \(valid\). We assume that this function only takes completed grids as input. A matrix is valid if all rows and columns are valid.

\[
    \begin{array}{lcl}
        valid & :: & Grid \rightarrow Bool \\
        valid~g & = & all~validRow~(rows~g)~\land \\
        & & all~validRow~(columns~g)
    \end{array}
\]

A row or column, in turn, is valid if it meets two conditions. First, it does not contain any duplicates. Second, all compartments within form straights.

\[
    \begin{array}{lcl}
        validRow & :: & Row ~ Square \rightarrow Bool \\
        validRow~ss & = & condition1~ss~\land \\
        & & condition2~ss
    \end{array}
\]

\subsection*{Condition 1}
\addcontentsline{toc}{subsection}{Condition 1}

Let’s implement \(condition1\). The only squares allowed to repeat across a row or column are black, empty ones. On top of that, we agree that two squares are duplicates when their values match, independent of their colour. The function \(condition1\) discards all black, empty cells and checks whether the values of the remaining squares repeat themselves. If not, it yields \(True\).

\begin{equation}\label{eq:condition1}
    \begin{array}{lcl}
        condition1 & :: & Row~Square \rightarrow Bool \\
        condition1~ss & = & noDuplicates~[value~s~|~s \leftarrow ss,~not~(black~s \land empty~s)]
    \end{array}
\end{equation}
\[
    \begin{array}{lcl}
        noDuplicates & :: & Eq~a \Rightarrow [a] \rightarrow Bool\\
        noDuplicates~[] & = & True \\
        noDuplicates~(x:xs) & = & all~(\neq x)~xs \land noDuplicates~xs\\
    \end{array}
\]

\subsection*{Condition 2}
\addcontentsline{toc}{subsection}{Condition 2}

The second condition is that the values within all white compartments form straights.

\begin{equation}\label{eq:condition2}
    \begin{array}{lcl}
        condition2 & :: & Row ~ Square \rightarrow Bool\\
        condition2 ~ ss & = & all ~ (straight ~ . ~ values) ~ . ~ whiteCompartments
    \end{array}
\end{equation}

We can implement the function \(straight\) based on its definition. When we sort the values in ascending order, there should not be any gaps between them. \(Data.List\) provides the function \(sort ~ :: ~ Ord~a => [a] \rightarrow [a]\) that sorts in ascending order. Using this function, we can define \(straight\) as

\[
    \begin{array}{lcl}
        straight & :: & [Int] \rightarrow Bool\\
        straight & = & noGaps~.~sort
    \end{array}
\]

If we have two values \(v_1\) and \(v_2\), a gap means \(|v_2-v_1|>1\). In words, the gap between the two integer values is something other than 1. It’s important to note that \(noGaps\) needs input lists in ascending order.

\[
    \begin{array}{lcl}
        noGaps & :: & [Int] \rightarrow Bool\\
        noGaps~[] & = & True \\
        noGaps~[x] & = & True \\
        noGaps~(x:xs) & = & x+1==head~xs \land noGaps~xs
    \end{array}
\]

\newpage
\section*{Improvements}
\addcontentsline{toc}{section}{Improvements}

As a reminder, \(validRow\) is defined as follows

\begin{equation}\label{eq:validrow}
    \begin{array}{lcl}
        validRow & :: & Row ~ Square \rightarrow Bool \\
        validRow~ss & = & condition1~ss~\land condition2~ss
    \end{array}
\end{equation}

In the following, we want to simplify \(validRow\). Right now, the function \(straight\) inside $condition2$ works in two steps. It sorts the values inside each white compartment by applying \(sort\) and then checks whether there are gaps through \(noGaps\). However, we argue that, in combination with \(condition1\), we can drop both $sort$ and $noGaps$. Instead, we only need to check that the minimum and maximum values within the compartment are less apart than the compartment’s size. In mathematical terms, we want to prove

\begin{equation*}
    \begin{split}
        &\quad validRow\\
        =&\quad\quad\{\text{\ref{eq:validrow}, definition of $validRow$}\}\\
        &\quad condition1 ~ ss \land condition2 ~ ss\\
        =&\quad\quad\{\text{\ref{eq:condition2}, definition of $condition2$}\}\\
        &\quad condition1 ~ ss \land all~(straight~.~values)~(whiteCompartments ~ ss)\\
        =&\quad\quad\{\text{This needs to be proved}\}\\
        &\quad condition1 ~ ss \land all~(distanceOk~.~ values) ~(whiteCompartments ~ ss)
    \end{split}
\end{equation*}

With \(distanceOk\) being defined as

\[
    \begin{array}{lcl}
        distanceOk & :: & [Int] \rightarrow Bool\\
        distanceOk~xs & = & maximum~xs - minimum~xs < length~xs~
    \end{array}
\]

We can then re-write \(condition2\) as

\[
    \begin{array}{lcl}
        condition2 & :: & Row ~ Square \rightarrow Bool\\
        condition2 & = & all ~ (distanceOk ~ . ~ values) ~ . ~ whiteCompartments
    \end{array}
\]

\newpage
\subsection*{Proof}
\addcontentsline{toc}{subsection}{Proof}

We need to establish two theorems.

First, Equation \ref{a-simple-solver-theorem-straight}, which is an alternative definition for straight. It states that, if \(x\) is a list of length \(n\) that does not contain duplicates and has its minimum and maximum be no further apart than \(n-1\), then \(x\) forms a straight.

\begin{equation}\label{a-simple-solver-theorem-straight}
    \begin{array}{c}
        (i\neq j \Rightarrow x_i\neq x_j) \land (max_x-min_x=n-1) \Rightarrow x\text{ forms a straight}\\
        x = \{x_1,\dots,x_n\}
    \end{array}
\end{equation}

The proof is simple. Because of \((i\neq j \Rightarrow x_i\neq x_j)\), \(x\) can be sorted into a list of ascending order. Namely, \([x_1,\dots ,x_n]\) with \(min_x=x_1\) and \(max_x=x_n\). Because of \((max_x-min_x=n-1)\), the step size between elements cannot be larger than \(1\), as demonstrated by the following equation.

\begin{equation*}
    \begin{array}{lcl}
        x_1 & = & x_1 \\
        x_2 & = & x_1 + 1 \\
        x_3 & = & x_2 + 1 = (x_1 + 1) + 1 = x_1 + 2\\
        & \dots & \\
        x_{n} & = & x_1 + (n-1)
    \end{array}
\end{equation*}

This makes $x$ a straight by definition. Now that we have established the correctness of Equation \ref{a-simple-solver-theorem-straight}, we can use it to redefine our function $straight$ as follows.

\begin{equation}\label{a-simple-solver-definition-straight}
    \begin{array}{lcl}
        straight & :: & [Int] \rightarrow Bool\\
        straight ~ xs & = & noDuplicates ~ xs \land distanceOk ~ xs
    \end{array}
\end{equation}

The second theorem is Equation \ref{a-simple-solver-theorem-duplicates}. It states that, whenever we have a list without duplicates, any subset of this list will not have duplicates, either. This is relevant because in \(condition2\), we already check that there are no duplicates across non-empty black cells. Because white compartments are subsets of these, this check already includes them.

\begin{equation}\label{a-simple-solver-theorem-duplicates}
    \begin{array}{c}
        (i\neq j) \Rightarrow (x_i\neq x_j) \Rightarrow (y_i\neq y_j)\\
        X \supset Y, ~ x \in X, ~ y \in Y 
    \end{array}
\end{equation}

\newpage
Now, we are ready to complete the previous equation.
\begin{equation*}
    \begin{split}
        &\quad validRow\\
        =&\quad\quad\{\text{\ref{eq:validrow}, definition of $validRow$}\}\\
        &\quad condition1 ~ ss \land condition2 ~ ss\\
        =&\quad\quad\{\text{\ref{eq:condition2}, definition of $condition2$}\}\\
        &\quad condition1 ~ ss \land all~(straight~.~values)~(whiteCompartments ~ ss)\\
        =&\quad\quad\{\text{\ref{a-simple-solver-definition-straight}, alternative definition of $straight$}\}\\
        &\quad condition1 ~ ss \land all~((\setminus x \rightarrow noDuplicates ~ x \land distanceOk ~ x)~.~ values) ~(\dots)\\
        =&\quad\quad\{\text{\ref{a-simple-solver-theorem-duplicates}, $condition1$ includes $noDuplicates$}\}\\
        &\quad condition1 ~ ss \land all~(distanceOk ~.~ values) ~(whiteCompartments ~ ss)
    \end{split}
\end{equation*}