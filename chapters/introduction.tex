\chapter{Introduction}\label{chap:introduction}

In the field of functional programming, it is rather difficult \textbf{not} to come across \textit{Why Functional Programming Matters} by Hughes~\cite{hughes1989functional}. As of 26.10.2025, it has been cited 1,600 times and has inspired later works that echo its title~\cite{website-scholar}. Such as \textit{How Functional Programming Mattered} and \textit{Why Functional Programming Really Matters}~\cite{hu2015functional, bailes2003functional}. It presents the following definition:

\begin{quote}
    Functional programming is so called because its fundamental operation is the application of functions to arguments. A main program itself is written as a function that receives the program’s input as its argument and delivers the program’s output as its result. Typically the main function is defined in terms of other functions, which in turn are defined in terms of still more functions, until at the bottom level the functions are language primitives.
\end{quote}

Equations~\ref{eq:id} and~\ref{eq:map} illustrate such language primitives in Haskell, the programming language used throughout this thesis~\cite{website-haskell-prelude}.

\begin{equation}\label{eq:id}
    \begin{array}{lcl}
        id & :: & a \rightarrow a \\
        id~x & = & x
    \end{array}
\end{equation}

\begin{equation}\label{eq:map}
    \begin{array}{lcl}
        map & :: & (a \rightarrow b) \rightarrow [a] \rightarrow [b] \\
        map~f~(x:xs) & = & f~x:map~f~xs
    \end{array}
\end{equation}

Functional programming is considered a branch of declarative programming~\cite{van2009programming}. In contrast to an imperative style, the focus is on describing what a program does rather than how it does it~\cite{nikolaeva2024survey}. Take \ref{eq:fibonacci-implementation} as an example. It shows how easy it is to define the function \textit{fibonacci} in Haskell. It is basically equal to \ref{eq:fibonacci-definition}, its mathematical definition~\cite{ scott2014origin}. There is no need to specify the flow of control. The program knows what to do~\cite{hughes1989functional}.

\begin{equation}\label{eq:fibonacci-implementation}
    \begin{array}{lcl}
        fibonacci & :: & Int \rightarrow Int \\
        fibonacci~0 & = & 0 \\
        fibonacci~1 & = & 1 \\
        fibonacci~n & = & fibonacci~(n-1)+fibonacci~(n-2)
    \end{array}
\end{equation}

\begin{equation}\label{eq:fibonacci-definition}
    \begin{array}{lcl}
        f(0) & = & 0 \\
        f(1) & = & 1 \\
        f(n) & = & f(n-1)+f(n-2), \quad (n \geq 2)
    \end{array}
\end{equation}

A function does nothing more than compute its result. There is no state, and there are no side effects. Hence, we can use its left and right sides -- its function call and its result -- interchangeably. We call this property referential transparency. It makes it possible to reason about functions, just as we do in mathematics. We refer to this as equational reasoning~\cite{hughes1989functional}.

We can apply equational reasoning for various purposes. Let’s take a look at \ref{eq:fibonacci-2}. Here, we use it to prove that $fibonacci~2$ equals $1$. This example also gives a glimpse into the notation we use throughout the thesis. In general, we write functions the same way we would in Haskell. On top, the text in curly brackets between transformation steps provides information on the applied theorems.

\begin{equation}\label{eq:fibonacci-2}
    \begin{array}{cl}
        & fibonacci~2 \\
        = & \quad \{\text{\ref{eq:fibonacci-implementation}, definition of $fibonacci$}\} \\
        & fibonacci~(2-1)+fibonacci~(2-2) \\
        = & \quad \{\text{subtraction}\} \\
        & fibonacci~1+fibonacci~0 \\
        = & \quad \{\text{\ref{eq:fibonacci-implementation}, definition of $fibonacci$}\} \\
        & 1+0 \\
        = & \quad \{\text{addition}\} \\
        & 1
    \end{array}
\end{equation}

In his book, \textit{Pearls of Functional Algorithm Design}, Bird discusses a more sophisticated application of equational reasoning~\cite{bird2010pearls}. He explores the idea of using it not only to prove the properties of algorithms, but also to design them altogether. In the chapter \textit{A Simple Sudoku Solver}, he demonstrates this idea by implementing a Sudoku solver in a two-step process. First, he comes up with a simple, obviously correct, but highly inefficient version of the algorithm. Then, he transforms it into a more complex but efficient version through equational reasoning. As a side note, Bird also published the paper \textit{Functional pearl: A program to solve sudoku}, which contains duplicate content~\cite{bird2006functional}.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=1]{graphics/grid-comparison-sudoku-str8ts.pdf}
    \caption{Comparison between Sudoku and Str8ts}
    \label{fig:grid-comparison-sudoku-str8ts}
\end{figure}

\newpage
This thesis explores whether we can apply Bird’s approach to Str8ts, a puzzle similar to Sudoku. See Figure ~\ref{fig:grid-comparison-sudoku-str8ts} for a side-by-side comparison. In addition, we aim to present our work in the distinctive style of a functional pearl. Functional pearls emphasize instructional value over novelty. They strive to be polished, elegant, instructive, and entertaining. We have attempted to follow Bird’s guidelines from \textit{How to Write a Functional Pearl} throughout the entire thesis, but guarantee strict adherence only in the
chapters about algorithm design~\cite{Bi06}.

For implementation, we chose Haskell as our programming language, GHCup for tool management, and Stack for dependency management~\cite{website-haskell, website-ghcup, website-stack}. While other functional programming languages exist, we selected Haskell because it is well-maintained and actually rooted in academia. Its development began in September 1987, when a committee was formed at the Functional Programming Languages and Computer Architecture
conference to create a common standard for functional programming languages, which were rapidly emerging at the time. This effort culminated in the publication of the \textit{Haskell 1.0 Report} in April 1990~\cite{hudak2007history}.

Conceptually, we divide this thesis into three parts. The first part covers the chapters \nameref{chap:related-work} and \nameref{chap:str8ts}, where we situate our research within the existing literature and establish the rules of the Str8ts game. The second part includes the chapters \nameref{chap:data-representation}, \nameref{chap:a-simple-solver}, and \nameref{chap:an-advanced-solver}. Following Bird’s approach, we first develop a simple but inefficient solver and then refine it into a more sophisticated and efficient solver using equational reasoning. The third part consists of the \nameref{chap:runtime-analysis} chapter, in which we evaluate the performance of our algorithm. Finally, we summarize our findings in \nameref{chap:conclusion} and provide suggestions for future work in \nameref{chap:future-work}.