\chapter{An Advanced Solver}\label{chap:an-advanced-solver}

We successfully developed a simple Str8ts solver. However, in its current form, the algorithm remains highly inefficient, even with lazy evaluation. It computes all possible completions of the board and then searches for the first valid solution. In \textit{A Simple Sudoku Solver}, Bird presents a series of transformations that evolve an inefficient solver into a more sophisticated one. Since Str8ts and Sudoku share many structural similarities, we apply them to our problem domain.

\section*{Pruning}
\addcontentsline{toc}{section}{Pruning}
\label{sec:pruning}

Following Bird’s approach, we can improve the algorithm by incorporating pruning, which eliminates invalid completions earlier in the process and significantly reduces run-time. This method also more closely reflects how humans approach puzzle solving.

\subsection*{Transformation}
\addcontentsline{toc}{subsection}{Transformation}

We reuse the following transformation.

\begin{equation}\label{an-advanced-solver-theorem-prune}
    \begin{array}{rcl}
        advancedSolve & = & filter~valid\cdot expand\cdot choices\\
         & = & filter~valid\cdot expand\cdot prune\cdot choices
    \end{array}
\end{equation}

With \(prune\) and \(pruneBy\) being defined as follows.

\begin{equation*}
    prune = pruneBy~cols \cdot pruneBy ~ rows
\end{equation*}
\begin{equation*}
    \begin{array}{c}
        pruneBy~f = f\cdot map~pruneRow\cdot f\text{,}\\
        f \in \{rows,~columns\}
    \end{array}
\end{equation*}

\newpage
The following theorems need to be established for \ref{an-advanced-solver-theorem-prune} to be applicable. 
\begin{align}
    &filter~(p\cdot f) = map~f\cdot filter~p\cdot map~f\text{, when $f\cdot f = id$}\label{an-advanced-solver-prune-theorem-1}\\
    &map~f\cdot expand = expand\cdot f,~f\in\{rows,~columns\}\label{an-advanced-solver-prune-theorem-2}\\
    &filter~(all~p)\cdot cp = cp\cdot map~(filter~p)\label{an-advanced-solver-prune-theorem-3}\\
    &filter~validRow\cdot cp = filter~validRow\cdot cp\cdot pruneRow\label{an-advanced-solver-prune-theorem-4}
\end{align}

\subsection*{Implementation}
\addcontentsline{toc}{subsection}{Proof}
We need to define \(pruneRow\). We can prune by \(condition1\) or \(condition2\). We consider an element inside \(Matrix~Choices\) fixed if its length is 1. When pruning, it is helpful to focus on these fixed parts of the puzzle.
\[
    \begin{array}{lcl}
        pruneRow & :: & Row~Choices \rightarrow Row~Choices\\
        pruneRow & = & pruneByCondition1~.~pruneByCondition2
    \end{array}
\]

\subsubsection*{pruneByCondition1}
\addcontentsline{toc}{subsubsection}{pruneByCondition1}
The function \(pruneByCondition1\) looks at all fixed choices in rows and columns and eliminates them from other entries in the same row or column. The function $ remove $ never returns an empty array, because otherwise accessors, such as $whiteCompartments$, could throw null-pointer exceptions. 
\[
    \begin{array}{@{}l}
        \begin{array}{@{}lcl}
            pruneByCondition1 & :: & Row~Choices \rightarrow Row~Choices \\ pruneByCondition1~row & = & map~(remove~impossible)~row \\
        \end{array} \\
        \begin{array}{@{~~~~~~~~~~}r@{~}lcl}
            where & impossible & = & filter~singleton~row \\
        \end{array}
    \end{array}
\]
\[
    \begin{array}{lcl}
        remove & :: & Choices \rightarrow Choices \rightarrow Choices \\
        remove~\_~[~] & = & error\\
        remove~[~]~ys & = & ys\\
        remove~\_~[y] & = & [y]\\
        remove~(x:xs)~ys & = & remove~xs~[y~|~y \leftarrow ys,~value~y \neq value~x]
    \end{array}
\]
\subsubsection*{pruneByCondition2}
\addcontentsline{toc}{subsubsection}{pruneByCondition2}

The function \(pruneByCondition2\) looks at fixed choices within white compartments and how they clamp its range. However, before we start, we need to introduce new accessors \(compartments'\) and \(isWhiteCompartment'\), because we are now working with \(Matrix~Choices\) instead of \(Matrix~Square\).

\[
    \begin{array}{lcl}
        compartments' & :: & Row~Choices \rightarrow [Compartment~Choices]\\
        compartments' & = & groupBy ~ (\setminus x~y \rightarrow color~(head~x) == color~(head~y))
    \end{array}
\]
\[
    \begin{array}{lcl}
        isWhiteCompartment' & :: & Compartment ~ Choices \rightarrow Bool\\
        isWhiteCompartment' & = & white~.~head~.~head
    \end{array}
\]
\newpage
Then, the definition of \(pruneByCondition2\) is as follows.
\[
    \begin{array}{lcl}
        pruneByCondition2 & :: & Row~Choices \rightarrow Row~Choices \\
        pruneByCondition2 & = & concatMap~pruneCompByCondition2~.~compartments'
    \end{array}
\]
\[
    \begin{array}{l}
        \begin{array}{l}
        pruneCompByCondition2~::~ Compartment~Choices \rightarrow Compartment~Choices\\
        pruneCompByCondition2~comp
        \end{array}\\
        \begin{array}{@{\quad\quad|~}lcl}
            isWhiteCompartment'~comp & = & pruneWhiteCompByCondition2~comp\\
            otherwise & = & comp\\
        \end{array}\\
    \end{array}
\]
\[
    \begin{array}{l}
        \begin{array}{l}
        pruneWhiteCompByCondition2~::~Compartment~Choices \rightarrow Compartment~Choices\\
        pruneWhiteCompByCondition2~comp\\
        \end{array}\\
        \begin{array}{@{\quad\quad|~}lcl}
            not~(any~singleton~comp) & = & comp\\
            otherwise & = & map~(remove~invalid)~comp\\
        \end{array}\\
        \begin{array}{@{\quad\quad\quad\quad}r@{~}lcl}
            where & range & = & length~comp - 1\\
            & max & = & minimum~fixed + range\\
            & min & = & maximum~fixed - range\\
            & invalid & = & [c~|~c \leftarrow candidates, value~c > max \lor value~c < min]\\
        \end{array}
    \end{array}
\]

\subsection*{Proof}
\addcontentsline{toc}{subsection}{Proof}

Proofs for \ref{an-advanced-solver-prune-theorem-1}–\ref{an-advanced-solver-prune-theorem-3} are already provided by Bird himself. They also hold in our case, since we adopt the same definitions for the functions $rows$, $columns$, $expand$, and $cp$. Consequently, the only proof required from us is that of \ref{an-advanced-solver-prune-theorem-4}, which states that $pruneRow$ does not remove valid entries.

\section*{Single-Cell Expansion}
\addcontentsline{toc}{section}{Single-Cell Expansion}

Another improvement is to expand the choices only one step at a time, focusing on the most promising options first. In practice, this means prioritizing squares with fewer possible candidates. For example, if one square has only two possible values while another has six, it is more efficient to expand the former. This approach keeps the search tree smaller and allows the algorithm to converge faster.

\subsection*{Transformation}
\addcontentsline{toc}{subsection}{Transformation}

We apply one final transformation by Bird. Namely,
\begin{equation*}
    advancedSolve = search \cdot choices
\end{equation*}
\[
    \begin{array}{l}
        \begin{array}{l}
        search~m\\
        \end{array}\\
        \begin{array}{@{\quad\quad|~}lcl}
            not~(safe~m) & = & []\\
            complete~m' & = & [map~(map~head) ~m']\\
            otherwise & = & concat~(map~search~(expand1~m'))\\
        \end{array}\\
        \begin{array}{@{\quad\quad\quad\quad}r@{~}lcl}
            where & m' & = & prune~m\\
        \end{array}
    \end{array}
\]

$expand1$ is defined as
\[
    \begin{array}{l}
        \begin{array}{lcl}
        expand1 & :: & Matrix~[a] \rightarrow [Matrix~[a]]\\
        expand1~m & = & [rows1 \mathbin{+\!\!+} [row1 \mathbin{+\!\!+} [c]:~row2] \mathbin{+\!\!+} rows2~|~c \leftarrow cs]\\
        \end{array}\\
        \begin{array}{@{\quad\quad}r@{~}lcl}
            where & (rows1,~row:rows2) & = & break~(any~smallest)~m\\
            & (row1,~cs:row2) & = & break~smallest~row\\
            & smallest~x & = & length~x == n\\
            & n & = & minimum~(counts~m)\\
            & counts & = & filter~(>1)~.~map~length~.~concat
        \end{array}
    \end{array}
\]

The above equation holds true under the following conditions:
\begin{align}
    &expand = concatMap~expand\cdot expand1~\text{, on incomplete matrices}\label{an-advanced-solver-expand-theorem-1}\\
    &filter~p\cdot concat = concat\cdot map~(filter~p)\label{an-advanced-solver-expand-theorem-2}\\
    &filter~valid\cdot expand = filter~valid\cdot expand\cdot prune\label{an-advanced-solver-expand-theorem-3}
\end{align}

\subsection*{Implementation}
\addcontentsline{toc}{subsection}{Implementation}

We need to implement the function $safe$, which determines whether a matrix of choices is valid. We cannot use the existing functions $valid$ and $validRow$ here, as they operate on $Matrix~Square$ and $Row~Square$, rather than on $Matrix~Choices$ and $Row~Choices$. Therefore, we must define a new function, $ok$, that reuses $condition1$ and $condition2$ (from $validRow$) by applying them only to the fixed parts of the rows and columns.

\begin{equation*}
    \begin{array}{lcl}
        safe & :: & Matrix~Choices \rightarrow Bool \\
        safe~m & = & all~ok~(rows~m) \land all~ok~(columns~m)
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        ok & :: & Row~Choices \rightarrow Bool \\
        ok~xs & = & okByCondition1~xs \land okByCondition2~xs
    \end{array}
\end{equation*}

For \(okByCondition1\), we can reuse \(condition1~::~Row~Square \rightarrow Bool\) by just applying it on the fixed entries within a row. Implementing \(okByCondition2\) is a little bit trickier. We can check completed compartments only.

\begin{equation*}
    \begin{array}{lcl}
        okByCondition1 & :: & Row~Choices \rightarrow Bool \\
        okByCondition1~row & = & condition1~[s~|~[s] \leftarrow row]
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        okByCondition2 & :: & Row~Choices \rightarrow Bool \\
        okByCondition2~row & = & condition2~[s~|~c \leftarrow completeComps~row, [s] \leftarrow c]
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        completeComps & :: & Row~Choices \rightarrow [Compartment~Choices] \\
        completeComps & = & filter~(all~singleton)~.~compartments'
    \end{array}
\end{equation*}

To check whether a matrix is complete, we only have to see if all entries are singleton.

\begin{equation*}
    \begin{array}{lcl}
        complete & :: & Matrix~[a] \rightarrow Bool \\
        complete & = & all~(all~singleton)
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        singleton & :: & [a] \rightarrow Bool \\
        singleton~[\_] & = & True \\
        singleton~\_ & = & False
    \end{array}
\end{equation*}

\subsection*{Proof}
\addcontentsline{toc}{subsection}{Proof}

Because \ref{an-advanced-solver-expand-theorem-1} and \ref{an-advanced-solver-expand-theorem-2} are, again, valid out of the box as we use the exact definition for the functions $expand$ and $expand1$. Equation \ref{an-advanced-solver-expand-theorem-3} was discussed in the previous chapter. Hence, there is nothing left to do.