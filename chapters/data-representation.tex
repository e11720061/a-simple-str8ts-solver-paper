\chapter{Data Representation}\label{chap:data-representation}

We start by agreeing on a representation of the puzzle in Haskell. We introduce generic types to build upon.

\begin{equation*}
    \begin{array}{lcl}
        \textbf{type}~Matrix~a & = & [Row~a] \\
        \textbf{type}~Row~a & = & [a] \\
        \textbf{type}~Column~a & = & [a] \\
        \textbf{type}~Compartment~a & = & [a]
    \end{array}
\end{equation*}

The puzzle is played on a grid of size $n \times n$. We choose $n=9$ as it is the most common. But, if necessary, 9 can be replaced by any positive, integer number. Elements inside the grid are called squares. A $9 \times 9$ grid, as a consequence, contains a total of 81 squares.

\begin{equation*}
    \begin{array}{lcl}
        size & :: & Int \\
        size & = & 9
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        \textbf{type}~Grid & = & Matrix~Square
    \end{array}
\end{equation*}

Each square holds two attributes. A colour $\in\{White,~Black\}$ and a value $\in[0\dots n]$.

\begin{equation*}
    \begin{array}{lcl}
        \textbf{data}~Square & = & Square~\{colour~::~Colour,~value~::~Value\} \\
        \textbf{data}~Colour & = & White~|~Black \\
        \textbf{type}~Value & = & Int
    \end{array}
\end{equation*}

Squares with a value of 0 are empty. A complete grid does not contain any empty, white squares. However, it might contain empty, black squares. In the following, we will simply refer to empty, white squares as blank squares. We introduce the function $blank$ to check whether a square is blank or not.

\begin{equation*}
    \begin{array}{lcl}
        blank & :: & Square \rightarrow Bool \\
        blank~s & = & empty~s \land white~s
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        empty & :: & Square \rightarrow Bool \\
        empty & = & (==0)~.~value
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        white & :: & Square \rightarrow Bool \\
        white & = & not~.~black
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        black & :: & Square \rightarrow Bool \\
        black & = & (==Black)~.~colour
    \end{array}
\end{equation*}

\section*{Example}\addcontentsline{toc}{section}{Example}

The following is an example of an incomplete $9 \times 9$ grid. For the sake of readability, we abbreviated the constructors. We simply write $S$ for $Square$, $W$ for $White$, and $B$ for $Black$. For example, $S~W~3$ abbreviates $Square~White~3$.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=1]{graphics/grid-empty.pdf}
    \caption{Incomplete Str8ts puzzle}
    \label{fig:grid-empty-2}
\end{figure}

\begin{equation*}
    \left[
        \begin{array}{lcccccccccr}
            {[}&S~B~0&S~B~4&S~W~0&S~W~0&S~W~0&S~B~0&S~B~5&S~W~0&S~W~0&{]} \\
            {[}&S~B~6&S~W~0&S~W~1&S~W~0&S~W~0&S~B~0&S~W~0&S~W~0&S~W~0&{]} \\
            {[}&S~W~0&S~W~0&S~B~0&S~B~0&S~W~0&S~W~0&S~W~0&S~W~0&S~B~0&{]} \\
            {[}&S~W~0&S~B~0&S~W~0&S~W~7&S~W~0&S~W~0&S~B~0&S~W~0&S~W~0&{]} \\
            {[}&S~W~0&S~W~0&S~W~0&S~W~0&S~W~0&S~W~0&S~W~0&S~W~0&S~W~0&{]} \\
            {[}&S~W~0&S~W~0&S~B~0&S~W~0&S~W~0&S~W~0&S~W~0&S~B~0&S~W~3&{]} \\
            {[}&S~B~9&S~W~0&S~W~5&S~W~6&S~W~0&S~B~1&S~B~0&S~W~0&S~W~0&{]} \\
            {[}&S~W~0&S~W~0&S~W~0&S~B~0&S~W~0&S~W~0&S~W~0&S~W~0&S~B~0&{]} \\
            {[}&S~W~0&S~W~0&S~B~0&S~B~3&S~W~0&S~W~0&S~W~0&S~B~0&S~B~7&{]} \\
        \end{array}
    \right]
\end{equation*}

\section*{Accessors}\addcontentsline{toc}{section}{Accessors}

Last but not least, we have to define the functions $rows$, $columns$, and $compartments$. We aim for wholemeal programming, a term coined by Geraint Jones~\cite{hinze2009functional}. The goal of this paradigm is to view the data types as a whole and not succumb to \textit{Indexitis}. In our representation, we store a matrix as an array of rows. Hence, $rows$ is simply its input.

\[
    \begin{array}{lcl}
        rows & :: & Matrix~a \rightarrow Matrix~a \\
        rows & = & id
    \end{array}
\]

To make it easier for us, we use the module Data.List~\cite{website-haskell-list}. To access the columns, we can simply use the function $Data.List.transpose$.

\[
    \begin{array}{lcl}
        columns & :: & Matrix~a \rightarrow Matrix~a \\
        columns & = & transpose
    \end{array}
\]

In contrast to \(rows\) and \(columns\), the function $compartments$ is not polymorphic. It takes a row or column of type \([Square]\), as input and groups it into a list of white and black compartments. It is based on \(Data.List.groupBy\) and can be reverted by applying \(concat\).

\begin{equation*}
    \begin{array}{lcl}
        compartments & :: & [Square] \rightarrow [Compartment~Square] \\
        compartments & = & groupBy~(\setminus x~y \rightarrow color~x == color~y)
    \end{array}
\end{equation*}

In some cases, it is only necessary to access white compartments. For this purpose, we also introduce the function $whiteCompartments$.

\begin{equation*}
    \begin{array}{lcl}
        whiteCompartments & :: & [Square] \rightarrow [Compartment~Square] \\
        whiteCompartments & = & filter~isWhiteCompartment~.~compartments
    \end{array}
\end{equation*}

\begin{equation*}
    \begin{array}{lcl}
        isWhiteCompartment & :: & Compartment~Square \rightarrow Bool \\
        isWhiteCompartment & = & white~.~head
    \end{array}
\end{equation*}

The function $values$ is defined as

\begin{equation*}
    \begin{array}{lcl}
        values & :: & [Square] \rightarrow [Int] \\
        values & = & map~value
    \end{array}
\end{equation*}
