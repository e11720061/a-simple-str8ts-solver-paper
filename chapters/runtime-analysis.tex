\chapter{Run-Time Analysis}\label{chap:runtime-analysis}

In the previous chapter, we introduced $advancedSolve$. Our next step was to evaluate its performance through a run-time analysis. Initially, we planned to compare $simpleSolve$ with $advancedSolve$. However, $simpleSolve$ consistently hit the 60-second timeout, even for puzzles with difficulty Gentle. We were uncertain whether $simpleSolve$ could even complete before exhausting the available working memory. Therefore, we decided to solely focus on $advancedSolve$.

\section*{Machine}\addcontentsline{toc}{section}{Machine}

The used machine was a 16-inch MacBook Pro 2023 with an M3 Max chip. To ensure accurate measurements, all non-essential applications were closed during execution. Full software and hardware specifications are listed in Table~\ref{tab:macbook-software} and Table~\ref{tab:macbook-hardware} respectively.

\begin{table}[!h]
    \centering
    \begin{tabular}{l|l}
        Software property & Value \\\hline
        System version & macOS 14.1 \\
        Kernel version & Darwin 23.1.0 \\
    \end{tabular}
    \caption{Software properties}
    \label{tab:macbook-software}
\end{table}

\begin{table}[!h]
    \centering
    \begin{tabular}{l|l}
        Hardware property & Value \\\hline
        Chip & Apple M3 Max \\
        Number of cores & 14 \\
        Memory & 36 GB \\
    \end{tabular}
    \caption{Hardware properties}
    \label{tab:macbook-hardware}
\end{table}

\newpage

\section*{Setup}\addcontentsline{toc}{section}{Setup}

The goal was to create a framework to automate run-time analysis. We set up a Haskell project using GHCup and Stack. We implemented the solution discussed in the chapters \nameref{chap:data-representation}, \nameref{chap:a-simple-solver}, and \nameref{chap:an-advanced-solver}. For each chapter, we added a corresponding module (DataTypes, SimpleSolver, and AdvancedSolver). The code in each module is structured just like presented in this thesis. This makes it easy for the reader to follow. The project can be found here \href{https://github.com/e11720061/a-simple-str8ts-solver/tree/main/project}{a-simple-str8ts-solver/project}.

\section*{Data Acquisition}\addcontentsline{toc}{section}{Data Acquisition}

\begin{center}
    \href{https://www.str8ts.com/Print_Daily_Str8ts.aspx?solution=please&day=17/10/2025}{www.str8ts.com/Print\_Daily\_Str8ts.aspx?solution=please\&day=17/10/2025} 
\end{center}

For our run-time analysis, we collected data exclusively from the official website. We accessed puzzles via the URL above, which accepts a query parameter day in the format DD/MM/YYYY, enabling retrieval of puzzles from previous dates. At the time of writing this thesis, the earliest available puzzle was dated 24/11/2008. However, as of 17/10/2025, the website has restricted access to the most recent 31 puzzles.

\begin{listing}[!h]
\begin{mintedhaskell}
module PuzzleDownloader where

import PuzzleScraper ( getPuzzleDataFrom )

savePuzzlesAsTxt :: FolderPath -> StartDate -> EndDate -> IO ()
savePuzzlesAsTxt = forEachDateDo savePuzzleAsTxt

type Action = FolderPath -> Date -> IO ()

forEachDateDo :: Action -> FolderPath -> StartDate -> EndDate -> IO()
forEachDateDo action folderPath startDate endDate =
    mapM_ (\date -> do action folderPath date) (getDates startDate endDate)

savePuzzleAsTxt :: Action
savePuzzleAsTxt folderPath date = do
    maybePuzzleData <- getPuzzleDataFrom date
    case maybePuzzleData of
        Nothing -> putStrLn ("savePuzzleAsTxt: failed for date " ++ date)
        Just puzzleData -> writeInto folderPath fileName content
            where content = show puzzleData
            where fileName = toJisFormat date ++ ".txt"
\end{mintedhaskell}
\caption{Selected code parts from module \textit{PuzzleDownloader}}
\label{lst:module-puzzledownloader}
\end{listing}

\newpage

Manually retrieving the puzzles was unfeasible, so we created the \textit{PuzzleDownloader} module. It relies on another module, PuzzleScraper, that in turn, relies on the Scalpel library~\cite{website-hackage}. The entry point of the module is the function $downloadPuzzleData$. See Listing \ref{lst:module-puzzledownloader}, line 5. It scrapes the website and downloads all puzzles that were published between the start and end date into the specified folder.

\begin{listing}[!h]
\begin{mintedhaskell}
module PuzzleScraper where

type Puzzle = (Date, Difficulty, Grid, Solution)

type Date = String
type Difficulty = String
type Solution = Grid
\end{mintedhaskell}
\caption{Selected code parts from module \textit{PuzzleScraper}}
\label{lst:module-puzzlescraper}
\end{listing}

A puzzle is defined as $\textbf{type}~Puzzle = (Date,~Difficulty,~Grid,~Solution)$. See Listing \ref{lst:module-puzzlescraper} for the exact definition. Each puzzle is stored as a \textit{.txt} file by the $PuzzleDownloader$ module, and we convert it to a string using the $show$ function. This is possible because the puzzle consists of basic data types such as arrays and strings. For the Square type, we add the clause $deriving~(Show,~Eq,~Read)$. Storing puzzles in this format makes it straightforward to reconstruct them later (see Listing \ref{lst:module-fetchPuzzleData}).

\begin{listing}[!h]
\begin{mintedhaskell}
module PuzzleScraper where

fetchPuzzleData :: FilePath -> IO PuzzleData
fetchPuzzleData filePath = do
    contents <- readFile filePath
    return (read contents)
\end{mintedhaskell}
\caption{Selected code parts that parse puzzles}
\label{lst:module-fetchPuzzleData}
\end{listing}

\newpage
\section*{Data Selection}\addcontentsline{toc}{section}{Data Selection}

For this analysis, we limited our input to puzzles published between 01/01/2023 and 31/12/2023. Our data contains a total of 365 puzzles. Of these, the difficulties \textit{Moderate}, \textit{Tough}, and \textit{Diabolical} appear 91 times and make up 24.9\% each. The difficulty \textit{Gentle} appears 92 times, slightly more, and makes up 25.2\%. Although in their portfolio it states that there are also difficulty Kids and Extreme, online it seems like there are only these 4 difficulty levels available.

\begin{figure}[!h]
    \centering
    \includegraphics{graphics/runtimes-difficulties.pdf}
    \caption{Count of puzzles}
    \label{fig:runtime-difficulties}
\end{figure}

% \begin{table}[!h]
%     \centering
%     \begin{tabular}{l|rr}
%         Difficulty & Absolute & Relative \\\hline
%         Gentle & 92 & 25.21\% \\
%         Moderate & 91 & 24.93\% \\
%         Tough & 91 & 24.93\% \\
%         Diabolical & 91 & 24.93\% \\\hline\hline
%         Grand Total & 365 & 100.00\%
%     \end{tabular}
%     \caption{Count of puzzles}
%     \label{tab:runtimes-difficulties}
% \end{table}

The average number of blank cells is 48.52, with a minimum of 39 and a maximum of 59. The puzzle with the fewest blank cells is of gentle difficulty, while the one with the most is diabolical. The number of blank cells appears to increase with difficulty, suggesting it may be a good indicator of puzzle difficulty.

\begin{figure}[!h]
    \centering
    \includegraphics{graphics/runtimes-blanks.pdf}
    \caption{Count of blank squares}
    \label{fig:runtime-blanks}
\end{figure}

% \begin{table}[!h]
%     \centering
%     \begin{tabular}{l|rrr}
%         Difficulty & Minimum & Average & Maximum \\\hline
%         Gentle & 36 & 42.49 & 48 \\
%         Moderate & 42 & 45.86 & 50 \\
%         Tough & 48 & 51.92 & 57 \\
%         Diabolical & 51 & 54.60 & 60 \\\hline\hline
%         Grand Total & 36 & 48.70 & 60
%     \end{tabular}
%     \caption{Hardware Properties}
%     \label{tab:macbook-hardware}
% \end{table}

\newpage
\section*{Run-Time Measurement}\addcontentsline{toc}{section}{Runtime Measurement}

The RuntimeAnalyser module is responsible for measuring and recording the execution time of the algorithm. An overview of key code components is provided in Listing \ref{lst:module-runtimeanalyser-keycode}. The module’s primary entry point is the function $readAndAnalyzePuzzles$, which accepts the path to a .csv output file and populates it with runtime data along with metadata such as puzzle difficulty and date. If the algorithm fails to complete within a 60-second timeout, certain columns remain empty. For instance, the Solutions column, which indicates the number of solutions identified by the algorithm.

\begin{listing}[!h]
\begin{mintedhaskell}
module RuntimeAnalyser where

columnNames :: String
columnNames = ["Date",
    "Difficulty",
    "Solutions",
    "Official solution",
    "Run-time (ns)",
    "Blacks",
    "Blanks",
    "Symmetrical"
]

readAndAnalyzePuzzles :: OutputCsvPath -> PuzzleFolderPath -> Solver -> IO()
readAndAnalyzePuzzles outputCsvPath puzzleFolderPath solver = do
    writeAsNewLineInto outputCsvPath (intercalate excelSeparator columnNames)
    puzzlePaths <- getFilePaths puzzleFolderPath
    mapM_ (readAndAnalyzePuzzle solver outputCsvPath) puzzlePaths

readAndAnalyzePuzzle :: Solver -> OutputCsvPath -> PuzzlePath -> IO ()
readAndAnalyzePuzzle solver outputCsvPath puzzlePath = do
    putStrLn ("\nReading file " ++ puzzlePath ++ "\n")
    puzzleData@(_, _, grid, officialSolution) <- fetchPuzzleData puzzlePath
    putStrLn "\nGrid:\n"
    putStrLn (format grid)
    putStrLn "\nOfficial solution:\n"
    putStrLn (format officialSolution)
    analyzePuzzle solver outputCsvPath puzzleData
    putStrLn "\n--------------------------------------------------\n"
\end{mintedhaskell}
\caption{Key code components in module RuntimeAnalyser}
\label{lst:module-runtimeanalyser-keycode}
\end{listing}

% \begin{table}[!h]\label{eq:runtime-method}
%     \centering
%     \begin{tabular}{l|l}
%         Data Point & Data Type \\ \hline
%         Date & \([\text{01-01-2024},\text{31.12.2024}]\) \\
%         Difficulty & \(\{\text{Gentle},\text{Moderate},\text{Tough},\text{Diabolical}\}\) \\
%         Number of Solutions & \([1,\infty)\) \\
%         Equal to Official Solution & \(\{\text{True},\text{False}\}\) \\
%         Run-Time in Nanoseconds & \((0,60*10^9]\) \\
%         Number of Black Squares & \([1,81]\) \\
%         Number of Blank Squares & \([1,81]\) \\
%         Symmetrical & \(\{\text{True},\text{False}\}\) \\
%     \end{tabular}
%     \caption{Explanation of collected information}
%     \label{tab:runtime-analysis-information-types}
% \end{table}

\section*{Results}\addcontentsline{toc}{section}{Results}

The overall average runtime was 504.1 ms, with a minimum of 3.5 ms for a puzzle of Gentle difficulty and a maximum of 14,359.3 ms for a Diabolical puzzle. On average, the algorithm takes roughly twice as long to solve Moderate puzzles compared to Gentle ones, about 21 times longer for Tough puzzles compared to Moderate, and approximately three times longer for Diabolical puzzles compared to Tough. This indicates that the increase in average runtime is steepest between Moderate and Tough puzzles, while the growth slows when moving from Tough to Diabolical.

\begin{figure}[!h]
    \centering
    \includegraphics{graphics/runtimes-by-difficulty.pdf}
    \caption{Run-times (without outliers)}
    \label{fig:runtimes-by-difficulty}
\end{figure}

% \begin{table}[!h]
%     \centering
%     \begin{tabular}{l|rrr}
%         Difficulty & Minimum (ms) & Average (ms) & Maximum (ms) \\\hline
%         Gentle & 3501 & 12.39 & 69757.00 \\
%         Moderate & 5259 & 24.02 & 318948.00 \\
%         Tough & 19784 & 509090.74 & 14359.28 \\
%         Diabolical & 27689 & 1476.22 & 14321.71 \\\hline\hline
%         Grand Total & 3501 & 504079.75 & 14359.28
%     \end{tabular}
%     \caption{Run-times}
%     \label{tab:macbook-hardware}
% \end{table}

Figure \ref{fig:runtimes-by-blanks} shows the average run times grouped by the number of blank cells. Similar to the box plot shown earlier, run times tend to increase as the number of blank cells increases. The minimum number of blank cells in the dataset is 36. Interestingly, the lowest average run time—6 ms—is observed for a puzzle with 37 blank cells. The maximum number of blank cells is 60, and puzzles with this number of blanks exhibit the highest average run time of 4787.7 ms.

\begin{figure}[!h]
    \centering
    \includegraphics{graphics/runtimes-by-blanks.pdf}
    \caption{Average run-times by blank squares}
    \label{fig:runtimes-by-blanks}
\end{figure}

% \begin{table}[!h]
%     \centering
%     \begin{tabular}{rr}
%         Blanks & Average (ms) \\\hline
%         36 & 6.53 \\
%         37 & 6.01 \\
%         38 & 6.14 \\
%         39 & 7.08 \\
%         40 & 7.86 \\
%         41 & 6.85 \\
%         42 & 11.63 \\
%         43 & 16.89 \\
%         44 & 25.24 \\
%         45 & 22.91 \\
%         46 & 23.09 \\
%         47 & 14.75 \\
%         48 & 41.37 \\
%         49 & 111.59 \\
%         50 & 430.28 \\
%         51 & 397.75 \\
%         52 & 445.34 \\
%         53 & 918.84 \\
%         54 & 621.25 \\
%         55 & 1876.16 \\
%         56 & 1876.84 \\
%         57 & 1729.40 \\
%         58 & 2198.59 \\
%         59 & 1190.80 \\
%         60 & 4787.75 \\
%     \end{tabular}
%     \caption{Average run-times by blank squares}
%     \label{tab:runtimes-by-blanks}
% \end{table}